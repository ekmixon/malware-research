from os import path, getcwd
from  base64 import b64decode
import json
import string
import idaapi


def rc4_crypt(key, data):
    """Return the decrypted string."""
    S = list(range(256))
    j = 0

    for i in list(range(256)):
        j = (j + S[i] + ord(key[i % len(key)])) % 256
        S[i], S[j] = S[j], S[i]

    j = 0
    y = 0
    out = []

    for byte in data:
        j = (j + 1) % 256
        y = (y + S[j]) % 256
        S[j], S[y] = S[y], S[j]
        out.append(chr(byte ^ S[(S[j] + S[y]) % 256]))
    return ''.join(out)


def get_start_addr(ea):
    """Return the address of the function (the start address of the function)."""
    return list(FuncItems(ea))[0]


def get_call_list(ea):
    """Find the functions that called from the given function and return list of functions addresses."""
    dism_addr_list = list(FuncItems(ea))
    return [get_operand_value(addr, 0) for addr in dism_addr_list if print_insn_mnem(addr) == 'call']


def sanitize_string(name, t='var'):
    """Return the sanitized string by its type."""
    if t == 'dll':
        return "".join([c for c in name if c in string.ascii_letters]).capitalize()
    elif t == 'var':
        return "".join([c for c in name if c in string.ascii_letters])[:20].capitalize()


def check_pattern(addr_list,pattern):
    """Check if the instruction patterns are matched"""
    return [print_insn_mnem(addr) for addr in addr_list] == pattern


def scan_key(base_address):
    """Scan the strings setup function and find the decryption key and decryption func.

        Args:
        base_address -- the address for Oski stringsSetup function

        Returns:
            key -- decryption key
            decrypt_func_addr -- decryption function address
    """

    key = ''
    dism_addr_list = list(FuncItems(base_address))
    for addr in dism_addr_list:
        # check disassembly line
        if (print_insn_mnem(addr) != 'mov' and
        get_operand_type(addr, 0) != 2 and  # check for o_mem (Direct Memory Reference)
        get_operand_type(addr, 1) != 5):  # check for o_imm (Immediate Value)
            continue
        data_addr = get_operand_value(addr, 0)
        key_var_refs = []
        key_string_ref = get_operand_value(addr, 1)
        if list(XrefsTo(key_string_ref, 0)):  # has only 1 refs
            key_var_refs = list(XrefsTo(data_addr, 0))
            if len(key_var_refs) == 2:  # the second ref is for the usage of the ley within the decryption func
                key = idc.get_strlit_contents(key_string_ref).decode('utf-8')
                print(f"The decryption key is: {key}")

                if get_start_addr(key_var_refs[0].frm) == dism_addr_list[0]:  # validate ref address
                    decrypt_func_addr = get_start_addr(key_var_refs[1].frm)
                else:
                    decrypt_func_addr = get_start_addr(key_var_refs[0].frm)
                    set_name(decrypt_func_addr, 'decrypt_func', SN_NOWARN)
                print(f"The decryption func is: {hex(decrypt_func_addr)}")

                return key, decrypt_func_addr


def strings_setup(base_address, key, decrypt_func_addr):
    """Find the pattern for string setup, set name and comment for the decrypted string and add
        it to dictionary.

        Args:
        base_address -- the address for Oski stringsSetup function
        key -- decryption key
        decrypt_func_addr -- decryption function address
    """

    """decryption pattern
    push    offset aGjnzinipsemrzq
    call    decrypt
    add     esp, 4
    mov     dword_14015C0, eax
    """
    pattern = ['push', 'call', 'add', 'mov']
    dism_addr_list = list(FuncItems(base_address))
    for i in range(len(dism_addr_list)-len(pattern)):
        if (
            check_pattern(dism_addr_list[i : i + len(pattern)], pattern)
            and get_operand_value(dism_addr_list[i + 1], 0)
            == decrypt_func_addr
        ):
            b64_addr = list(DataRefsFrom(dism_addr_list[i]))[0]
            b64_string = idc.get_strlit_contents(b64_addr).decode('utf-8')  # get the b64 string
            var_addr = list(DataRefsFrom(dism_addr_list[i + 3]))[0]
            decoded_b64 = b64decode(b64_string)
            decrypted = rc4_crypt(key, decoded_b64).replace('\x00', '?')

            strings_dic[var_addr] = decrypted
            set_cmt(var_addr, decrypted, 0)  # add comment with the full decrypted string
            name = sanitize_string(decrypted, 'var')
            set_name(var_addr, f'a{name}', SN_NOWARN)
    print(f"{len(strings_dic)} decrypted strings")
    if len(strings_dic) <= 0:
        print('\n[+] Error on decryption the strings\n')
        exit(0)


def set_LoadLib_GetProc(proc_setup_func_addr):
    """Set LoadLibraryA and GetProcAddress within Oski's procsSetup function."""
    for addr, value in strings_dic.items():
        if 'LoadLibrary' in value or 'GetProcAddress' in value:
            for ref in XrefsTo(addr, 0):
                if get_start_addr(ref.frm) == proc_setup_func_addr:

                    last_addr = ref.frm
                    while (print_insn_mnem(last_addr) != 'call'):  # call to LoadLib/GetProc
                        last_addr = next_head(last_addr)
                    assign_addr = next_head(last_addr)
                    while (print_insn_mnem(assign_addr) != 'mov'):  # assign the return value to var (func name)
                        assign_addr = next_head(assign_addr)

                    if (
                        get_operand_type(assign_addr, 0) == 2
                        and get_operand_type(assign_addr, 1) == 1
                    ):
                        func_addr = get_operand_value(assign_addr, 0)
                        set_name(func_addr, value, 0x800)  # SN_FORCE


def procs_setup(base_address):
    """Find the pattern for retrieving dynamically the address of functions by using GetProcAddress API,
        set the name for the retrieved functions, and add it to dictionary.

        Args:
        base_address -- the address for Oski procsSetup function
    """

    """GetProc pattern
    mov     ecx, aExitprocess
    push    ecx             ; lpProcName
    mov     edx, [ebp+pKernel32Base]
    push    edx             ; hModule
    call    GetProcAddress_0
    mov     dword_4317B4, eax
    """
    pattern = ['mov', 'push', 'mov', 'push', 'call', 'mov']
    dism_addr_list = list(FuncItems(base_address))
    for i in range(len(dism_addr_list)-len(pattern)):
        if check_pattern(
            dism_addr_list[i : i + len(pattern)], pattern
        ) and "GetProcAddress" in print_operand(dism_addr_list[i + 4], 0):
            if get_operand_type(dism_addr_list[i + 1],
                                0) == 0x5:  # when the function name isn't encrypted
                proc_string_addr = list(DataRefsFrom(dism_addr_list[i + 1]))[0]
                proc_name = idc.get_strlit_contents(proc_string_addr).decode('utf-8')
            else:
                proc_string_addr = list(DataRefsFrom(dism_addr_list[i]))[0]
                proc_name = strings_dic[proc_string_addr]

            var_addr = list(DataRefsFrom(dism_addr_list[i + 5]))[0]
            set_name(var_addr, proc_name, 0x800)  # SN_FORCE
            procs_dic[var_addr] = proc_name
    print(f"{len(procs_dic)} dynamic procs")


def dlls_setup(base_address):
    """Find the pattern for loading dynamically DLLs by using LoadLibrary API,
        set the name for the retrieved dll.

        Args:
        base_address -- the address for Oski procsSetup function
    """

    """LoadLibrary pattern
    mov     eax, aBcryptdll
    push    eax             ; lpLibFileName
    call    LoadLibraryA
    mov     [ebp+hModule], eax
    """
    pattern = ['mov', 'push', 'call', 'mov']
    dism_addr_list = list(FuncItems(base_address))
    pFunc = idaapi.get_func(base_address)
    pFrame = ida_frame.get_frame(base_address)
    counter_dlls = 0
    for i in range(len(dism_addr_list)-len(pattern)):
        if check_pattern(
            dism_addr_list[i : i + len(pattern)], pattern
        ) and "LoadLibrary" in print_operand(dism_addr_list[i + 2], 0):
            dll_string_addr = list(DataRefsFrom(dism_addr_list[i]))[0]
            dll_name = get_cmt(dll_string_addr,0)
            # rename stack variable
            inst = DecodeInstruction(dism_addr_list[i + 3])
            offset = (idaapi.calc_stkvar_struc_offset(pFunc, inst, 0))
            name = sanitize_string(dll_name, 'dll')
            ida_struct.set_member_name(pFrame, offset, f'h{name}')
            counter_dlls += 1
    print(f"{counter_dlls} dynamic dlls")


def oski_setup(WinMain_address):
    """Decrypt and rename the strings, resolve the functions and Dlls names/addresses,
        and dump the data to JSON file.

        Args:
        WinMain_address -- the address for Oski's Main function
    """

    print('[+] Oski Builder started')

    global strings_dic, procs_dic
    strings_dic = {}
    procs_dic = {}
    dump_file = path.join(getcwd(), 'oski_strings_dump.json')

    call_func_list = get_call_list(WinMain_address)  # get the function in main
    if len(call_func_list) <= 0:
        print('\n[+] Error on finding Oski main functions\n')
        exit(0)

    print('[+] Strings decryption')
    dec_key, decrypt_func = scan_key(call_func_list[0])  # first function: stringsSetup
    strings_setup(call_func_list[0], dec_key, decrypt_func)

    print('[+] Set LoadLibrary and GetProcAddress')
    set_LoadLib_GetProc(call_func_list[1])  # second function: procSetup

    print('[+] Functions and DLLs loading')
    dlls_setup(call_func_list[1])
    procs_setup(call_func_list[1])

    print(f'[+] Dump strings to {dump_file}')
    with open(dump_file, 'w') as f:
        json.dump([{'decryption_key': dec_key}, {'decrypted strings': strings_dic}, {'loaded functions': procs_dic}],
                  f,indent=4, ensure_ascii=True)

    print('[+] Oski Builder finished')


if __name__ == "__main__":
    oski_setup(here())